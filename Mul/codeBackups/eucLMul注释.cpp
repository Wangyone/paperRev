#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;

/**
 * @brief 计算时间序列相空间重构的欧式距离平方矩阵
 *
 * 该函数对多元时间序列进行相空间重构，然后计算重构向量间的欧式距离平方矩阵。
 * 支持零滞后（m=0）和非零滞后（m>0）两种情况。
 *
 * @param x 输入的时间序列矩阵，维度为 N × d
 *          - N: 时间点数量，时间从t=1开始编号
 *          - d: 变量维度（多元时间序列的变量数）
 * @param m 滞后参数（时间延迟），决定重构时的滞后步长
 *          - m=0: 使用原始数据，不进行滞后重构
 *          - m>0: 将当前时间点与滞后m步的时间点拼接形成重构向量
 *
 * @return arma::mat 欧式距离平方矩阵，维度为 (N-m) × (N-m)
 *         矩阵元素 Euc(j,k) = ||Y(j) - Y(k)||²
 *         其中 Y(i) 是第i个重构向量
 *
 * @details
 * 当 m>0 时，进行相空间重构：
 *   Y(i) = [X(i+1), X(i+1+m)] ∈ ℝ^{2d}，其中 i = 0, 1, ..., N-m-1
 *   注意：索引从0开始，但对应时间点从1开始
 *   距离计算：Euc(j,k) = ||X(j+1)-X(k+1)||² + ||X(j+1+m)-X(k+1+m)||²
 *
 * 当 m=0 时：
 *   Y(i) = X(i+1) ∈ ℝ^{d}，其中 i = 0, 1, ..., N-1
 *   距离计算：Euc(j,k) = ||X(j+1)-X(k+1)||²
 *
 * 该函数利用距离矩阵的对称性优化计算，只计算上三角部分然后复制到对称位置。
 *
 * @example
 * // 示例：二维时间序列 (d=2)，N=5个时间点，时间从t=1开始
 * // x(0,:) = [x1,y1]  // t=1
 * // x(1,:) = [x2,y2]  // t=2
 * // x(2,:) = [x3,y3]  // t=3
 * // x(3,:) = [x4,y4]  // t=4
 * // x(4,:) = [x5,y5]  // t=5
 * //
 * // 当 m=1 时：
 * // 重构向量 Y(0)=[x1,y1,x2,y2], Y(1)=[x2,y2,x3,y3], ...
 * // 距离矩阵维度为 4×4
 * //
 * // 当 m=2 时：
 * // 重构向量 Y(0)=[x1,y1,x3,y3], Y(1)=[x2,y2,x4,y4], ...
 * // 距离矩阵维度为 3×3
 */
// [[Rcpp::export]]
arma::mat eucL(arma::mat x, int m)
{
  // 计算重构后的向量数量：当滞后为m时，可以构造 N-m 个重构向量
  // 注意：索引从0开始，但数据从t=1开始
  int nY = x.n_rows - m; // nY = N - m，重构向量的数量
  int d = x.n_cols;      // 原始数据的维度（变量个数）

  // 声明重构矩阵Y，每行是一个重构后的相空间向量
  arma::mat Y;

  // ============================================================
  // 情况1: m = 0（无滞后，直接使用原始数据）
  // ============================================================
  if (m == 0)
  {
    // 当m=0时，不进行重构，直接使用原始时间序列
    Y = x;
  }
  // ============================================================
  // 情况2: m > 0（有滞后，进行重构）
  // ============================================================
  else
  {
    // 分配重构矩阵Y的内存：nY行，2d列
    // 因为每个重构向量包含当前点和滞后m点的信息
    Y.set_size(nY, 2 * d);

    // 重构过程：构造向量 Y(0), Y(1), ..., Y(nY-1)
    // 对于每个 i = 0, 1, ..., nY-1:
    //   Y(i) = [X(i+1), X(i+1+m)]
    //         其中 X(i+1) 是原始时间序列在时间点t=i+1的d维观测值
    //         X(i+1+m) 是滞后m步后的d维观测值（时间点t=i+1+m）
    // 重构后的 Y(i) 是一个 2d 维向量

    // 假设原始数据 x 有 5 个时间点 (N=5)：
    //     第0行 (t=1): [x1, y1]
    //     第1行 (t=2): [x2, y2]
    //     第2行 (t=3): [x3, y3]
    //     第3行 (t=4): [x4, y4]
    //     第4行 (t=5): [x5, y5]
    //
    // 情况1: m=1 (nY = 5-1 = 4)
    //   Y(0) = [x1, y1, x2, y2]  // 连接 t=1 和 t=2
    //   Y(1) = [x2, y2, x3, y3]  // 连接 t=2 和 t=3
    //   Y(2) = [x3, y3, x4, y4]  // 连接 t=3 和 t=4
    //   Y(3) = [x4, y4, x5, y5]  // 连接 t=4 和 t=5
    for (int i = 0; i < nY; i++)
    {
      // 将第i行的当前点 x.row(i) 和滞后m点 x.row(i+m) 水平拼接
      // 注意：索引i对应时间点t=i+1，索引i+m对应时间点t=i+1+m
      // 形成一个2d维的行向量，存储在Y的第i行
      Y.row(i) = arma::join_rows(x.row(i), x.row(i + m));
    }
  }

  // ============================================================
  // 计算欧式距离平方矩阵
  // ============================================================
  // 创建一个 nY × nY 的零矩阵来存储距离
  arma::mat Euc(nY, nY, fill::zeros);

  // 遍历所有重构向量对 (Yj, Yk)
  for (int j = 0; j < nY; j++)
  {
    // 内循环从 j 开始，只计算 j ≤ k 的情况
    for (int k = j; k < nY; k++)
    {
      // 计算 Y(j) 和 Y(k) 之间的欧式距离平方
      // 公式: ||Y(j) - Y(k)||² = Σ_i (Y(j,i) - Y(k,i))²
      double dist = sum(square(Y.row(j) - Y.row(k)));

      // 存储到距离矩阵中
      Euc(j, k) = dist;

      // 如果是非对角线元素，利用对称性设置对称位置
      if (j != k)
      {
        Euc(k, j) = dist; // 因为距离矩阵是对称的
      }
    }
  }

  // 返回欧式距离平方矩阵
  // 注意：距离矩阵的行列索引从0到nY-1，对应重构向量Y(0)到Y(nY-1)
  return Euc;
}