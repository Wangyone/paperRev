#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;

/**
 * @brief 计算时间序列相空间重构的欧式距离平方矩阵
 *
 * 该函数对多元时间序列进行重构，然后计算重构向量间的欧式距离平方矩阵。
 * 使用矩阵运算优化，避免双重循环，显著提高计算速度。
 *
 * @param x 输入的时间序列矩阵，维度为 N × d
 *          - N: 时间点数量
 *          - d: 变量维度（多元时间序列的变量数）
 * @param m 滞后参数（时间延迟），决定重构时的滞后步长
 *          - m=0: 使用原始数据，不进行滞后重构
 *          - m>0: 将当前时间点与滞后m步的时间点拼接形成重构向量
 *
 * @return arma::mat 欧式距离平方矩阵，维度为 (N-m) × (N-m)
 *         矩阵元素 Euc(j,k) = ||Y(j) - Y(k)||²
 *         其中 Y(i) 是第i个重构向量
 *
 * @details
 * 优化原理：使用数学公式 ||a-b||² = ||a||² + ||b||² - 2⟨a,b⟩
 * 通过矩阵运算一次性计算所有点积，利用BLAS加速。
 *
 * 当 m>0 时，进行相空间重构：
 *   Y(i) = [X(i+1), X(i+1+m)] ∈ ℝ^{2d}，其中 i = 0, 1, ..., N-m-1
 *   注意：索引从0开始，但对应时间点从1开始
 *   距离计算：Euc(j,k) = ||X(j+1)-X(k+1)||² + ||X(j+1+m)-X(k+1+m)||²
 *
 * 当 m=0 时：
 *   Y(i) = X(i+1) ∈ ℝ^{d}，其中 i = 0, 1, ..., N-1
 *   距离计算：Euc(j,k) = ||X(j+1)-X(k+1)||²
 *
 * @example
 * // 示例：二维时间序列 (d=2)，N=5个时间点，时间从t=1开始
 * // x(0,:) = [x1,y1]  // t=1
 * // x(1,:) = [x2,y2]  // t=2
 * // x(2,:) = [x3,y3]  // t=3
 * // x(3,:) = [x4,y4]  // t=4
 * // x(4,:) = [x5,y5]  // t=5
 * //
 * // 当 m=1 时：
 * // 重构向量 Y(0)=[x1,y1,x2,y2], Y(1)=[x2,y2,x3,y3], ...
 * // 距离矩阵维度为 4×4
 */
// [[Rcpp::export]]
arma::mat eucL(arma::mat x, int m)
{
  // 获取数据维度
  int N = x.n_rows; // 时间点总数
  int d = x.n_cols; // 原始维度

  // 计算重构向量数量
  int nY = N - m; // 重构向量数量

  // ============================================================
  // 处理边界情况
  // ============================================================
  if (nY <= 0)
  {
    // 返回空矩阵
    return arma::mat();
  }

  // ============================================================
  // 构建重构矩阵 Y（向量化操作）
  // ============================================================
  arma::mat Y;

  if (m == 0)
  {
    // m=0: 直接使用原始数据
    Y = x;
  }
  else
  {
    // m>0: 拼接当前点和滞后点
    // 使用块操作一次性复制所有行，避免循环
    Y.set_size(nY, 2 * d);

    // 前半部分: 复制x的前nY行（对应时间点t=1到t=nY）
    Y.cols(0, d - 1) = x.rows(0, nY - 1);

    // 后半部分: 复制x的第m+1到nY+m行（对应时间点t=m+1到t=nY+m）
    Y.cols(d, 2 * d - 1) = x.rows(m, nY + m - 1);

    // 示例说明（二维时间序列，d=2，数据从t=1开始）：
    // 假设原始数据 x 有 5 个时间点 (N=5)：
    //     第0行 (t=1): [x1, y1]
    //     第1行 (t=2): [x2, y2]
    //     第2行 (t=3): [x3, y3]
    //     第3行 (t=4): [x4, y4]
    //     第4行 (t=5): [x5, y5]
    //
    // 情况1: m=1 (nY = 5-1 = 4)
    //   Y(0) = [x1, y1, x2, y2]  // 连接 t=1 和 t=2
    //   Y(1) = [x2, y2, x3, y3]  // 连接 t=2 和 t=3
    //   Y(2) = [x3, y3, x4, y4]  // 连接 t=3 和 t=4
    //   Y(3) = [x4, y4, x5, y5]  // 连接 t=4 和 t=5
    //
    // 情况2: m=2 (nY = 5-2 = 3)
    //   Y(0) = [x1, y1, x3, y3]  // 连接 t=1 和 t=3
    //   Y(1) = [x2, y2, x4, y4]  // 连接 t=2 和 t=4
    //   Y(2) = [x3, y3, x5, y5]  // 连接 t=3 和 t=5
  }

  // ============================================================
  // 使用矩阵运算计算欧式距离平方（核心优化）
  // ============================================================
  // 公式: ||Y_i - Y_j||² = ||Y_i||² + ||Y_j||² - 2⟨Y_i, Y_j⟩

  // 1. 计算每行的平方和（模长的平方）
  // 使用逐元素平方后按行求和
  arma::vec row_sq_sum = sum(square(Y), 1); // nY × 1 向量

  // 2. 计算点积矩阵：Y * Y^T
  // 这是计算量最大的部分，但Armadillo会调用BLAS进行优化
  arma::mat dot_prod = Y * Y.t(); // nY × nY 矩阵

  // 3. 使用广播机制组合结果
  // row_sq_sum * 1^T + 1 * row_sq_sum^T - 2*dot_prod
  arma::mat ones_row = arma::ones<arma::rowvec>(nY);
  arma::mat ones_col = arma::ones<arma::colvec>(nY);

  // 计算广播矩阵
  arma::mat broad_row = row_sq_sum * ones_row;     // 每列都是row_sq_sum
  arma::mat broad_col = ones_col * row_sq_sum.t(); // 每行都是row_sq_sum

  // 计算最终距离矩阵
  arma::mat Euc = broad_row + broad_col - 2.0 * dot_prod;

  // 确保对角线元素为0（处理数值精度问题）
  // 理论上，对角线上的距离应为0（向量与自身的距离）
  Euc.diag().zeros();

  // ============================================================
  // 返回欧式距离平方矩阵
  // ============================================================
  // 注意：距离矩阵的行列索引从0到nY-1，对应重构向量Y(0)到Y(nY-1)
  // 当 m>0 时：Euc(j,k) = ||X(j+1)-X(k+1)||² + ||X(j+1+m)-X(k+1+m)||²
  // 当 m=0 时：Euc(j,k) = ||X(j+1)-X(k+1)||²
  return Euc;
}